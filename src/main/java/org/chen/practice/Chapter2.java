package org.chen.practice;

/**
 * @author chendewei2401@gmail.com
 * @version V1.0
 * @date 2018年1月17日 下午1:34:02
 * @since JDK1.8
 * <p>
 * 一切皆是对象:
 *
 * 1，new将创建的对象存储在【堆】里，故用new创建一个对象--特别是小的、简单的对象，效率很低
 * 2，基本类型不用new来创建变量，而是创建一个并非是引用的‘自动’变量，这个变量直接存储值，并置于【栈】中，因此更加高效
 * 3，Java里每种基本类型所占存储空间大小是固定的。虽然无法针对机器进行特定优化，但可移植性更好
 * 4，所有数值类型都有正负号
 * 5，在C、C++、Java中，作用域由花括号的位置决定
 * 6，如果某基本类型变量是成员变量，即使没有初始化，Java会赋一个默认值；如果是一个局部变量，没有初始化会编译异常。
 * 7，方法名和参数列表合起来被称为方法签名，能唯一标识出一个方法。
 * 8，static字段对每个类来说都只有一份存储空间，而非static字段则对每个对象有一个存储空间。
 * 9，Java基本类型大小、默认值、最大值如下：
 *      boolean -       false               -
 *      byte    8bit    '\u0000'(null)      127
 *      char    16bit   0                   unicode
 *      short   16bit   0                   2^15-1（32767）
 *      int     32bit   0                   2^31-1（2147483647）
 *      long    64bit   0L                  2^63-1（9223372036854775807）
 *      float   32bit   0.0f
 *      double  64bit   0.0d
 *
 * 存储
 * 程序运行时，有5个不同的地方可以存储数据，包括：
 * 1，寄存器：位于CPU内部，是最快的存储区，但数量极少，因此CPU根据需求进行分配，程序不能控制。但C、C++可以向编译器建议寄存器的存储方式。
 * 2，栈：位于RAM，通过栈指针可以从处理器那里获得直接支持。栈指针如果向下移动，则分配新内存；若向上移动，则释放那些内存。
 *   这种分配方式快速有效，仅次于寄存器，但必须知道存储在栈里所有项的确切生命周期，以便上下移动指针。这一约束限制了程序的灵活性，
 *   因此Java将对象引用等放到栈，而对象放到了堆。
 * 3，堆：位于RAM，用于存放所有Java对象。在堆中分配存储十分灵活，使用new即可，当执行这些代码时，会自动在堆中分配，编译器不需要知道数据在堆里
 *   具体的生命周期。同时，在堆里进行存储分配和清理需要比在栈里花费更多时间。
 * 4，常量存储：常量值通常直接放到程序代码内部。
 * 5，非RAM存储：如果数据完全存活于程序之外，可以不受程序控制，在程序没有运行时也能存在。比如流对象和持久化对象。在流中，对象被转化为字节流发给另一台机器，
 *   而持久化对象被存储到磁盘。这种存储的要求在于：把对象转化为可以存储在其他媒介上的事物，在需要的时候，可恢复成常规的、基于RAM的对象。
 * 6，栈内存是程序编译是分配，而堆内存是程序运行时分配。如果使用的内存较多，要建议分配到堆上。
 * 7，线程拥有自己独立的栈空间，但共享堆空间：Stack is thread specific and Heap is application specific.
 *
 *
 *
 *
 */
public class Chapter2 {

    int i;

    char c;

    long l;

    public static void main(String[] args) {

        Chapter2 c2 = new Chapter2();
        int a = 0;
        System.out.println("c:{}" + c2.c);
        System.out.println(c2.i);
        System.out.println(c2.l);
        System.out.println(a);
    }

}
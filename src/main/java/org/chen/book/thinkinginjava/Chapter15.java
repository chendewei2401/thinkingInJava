package org.chen.book.thinkinginjava;

/**
 * @author chendewei2401@gmail.com
 * @version V1.0
 * @date 2018年2月5日 下午1:34:02
 * @since JDK1.8
 * <p>
 * 泛型:
 * 1，泛型希望通过解耦类或方法与所使用类型之间的约束，来扩大类或方法的表达能力。有许多原因促使泛型的出现，最直接的一个就是为了创造容器类
 * 2，泛型实现了参数化类型的概念，在你创建参数化类型的一个实例时，编译器会为你负责转型操作，并且保证类型的正确性
 * 3，与其使用Object，我们更喜欢暂时不指定类型，而是稍后再决定具体使用什么类型。要达到这个目的，需要使用类型参数，用尖括号括住，放在类名后面。
 *   然后在使用这个类型的时候，用实际的类型替换此类型参数。
 * 4，class Stack<T>{}：类名后的T告诉编译器这是个参数化类型，类型参数T在类被使用时被实际类型替换，
 *   即我们在定义一个可以持有T类型对象的Stack
 * 5，基本类型无法作为类型参数
 * 6，当使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法的时候，通常不必指明参数类型，因为编译器会为我们找出具体的类型。
 *   这称为类型参数推断(type argument inference)
 * 7，泛型方法与可变参数列表能够很好的共存
 * 8，泛型的一个重要好处是能够简单而安全的创建复杂的模型
 * 9，Java泛型是使用擦除来实现的，这意味着当你使用泛型时，任何具体的类型信息都被擦除了，因此List<String>和List<Integer>在运行时事实上
 *   是相同的类型。这两种形式都被擦除成它们的原生类型List。
 * 10，边界<T extends HasF>声明T必须是类型HasF或其子类。编译器实际上会把类型参数替换为它的擦除，即T擦除到HasF，就好像在类声明中用HasF替换了T一样。
 * 11，迁移兼容性：擦除并不是实现泛型的最好选择。如果Java从最开始就支持泛型，使类型参数为first class，那我们就能在参数类型上执行基于类型的语言操作和反射操作。
 *   擦除减少了泛型的泛化性，使其不如预期的有效，但擦除允许泛型代码和非泛型代码共存，使得向泛型的迁移成为可能。
 * 12，擦除主要的正当理由是从非泛化代码到泛化代码的转变，以及在不破坏现有类库的情况下，将泛型融入Java语言。但擦除的代价是显著的，泛型不能用于显式的引用运行时类型操作中，
 *   例如转型、instanceof操作和new表达式，因为所有关于参数的类型信息都丢失了。
 * 13，List<? extends Fruit>表示这是一个Fruit泛型或者其子类泛型，可以get但能set，因为里面取出来的对象可能是Fruit，也可能是Apple，但一定是可以转型为Fruit的对象，
 *   因此可以get；但放Apple就不满足Orange，放Orange又不满足Apple，因此不能set；
 *    List<? super Fruit>表示这是一个Fruit泛型或者其父类泛型，可以set但不能get。可以插入Fruit或其子类，但get有风险，因为不确定取出来是Fruit还是Object
 * 14，一个类不能实现同一个泛型接口的两种变体，因为擦除后会变成相同的接口
 */
public class Chapter15 {

    public static void main(String[] args) {

    }

}
